#include <gtk/gtk.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <string.h>
#include <sys/fcntl.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <time.h>
#include "client_handler.h"


#define BUFF_SIZE 2098

// #define CODE_LEN 4          // do dai lon nhat cua ma lenh
#define RECV_LEN 4          // do dai code nhan tu server

enum {
    LIST_ITEM = 0,
    N_COLUMNS
};

int client_sock_fd;
char name[30], *receiver_name;
user_array userArray;
int chat_count = 0;
char current_user[30], current_chat_user[30];
chat_history histories[300];

GtkBuilder *builder;
GtkWidget *window_login, *window_main, *current_window;
GtkWidget *btn_login, *btn_signup, *btn_send_msg, *edt_message;
GtkWidget *lbl_notify, *txt_chat_log, *txt_current_chat_user;
GtkWidget *edt_username, *edt_password;
GtkWidget *list, *vbox_user_list, *user_sw;
GtkTreeSelection *selection;


void initEvents();

void set_current_user_label(char *user);

void showUserList();

void appendUser(gchar *name, gint state, gint mess_count);

void initViews();

void initNetwork(int argc, char **argv);

void update_mess_count(char *sender);

void btn_signup_clicked_handler();

void btn_signin_clicked_handler();

void btn_sendmsg_clicked_handler();

void login_success();

void notify(gchar *message);

void signio_handler(int signo);

void valid_arguments(int argc, char *argv[], char *serv_ip, int *serv_port);


int main(int argc, char **argv) {
    gtk_init(&argc, &argv);


    initViews();
    initEvents();
    initNetwork(argc, argv);

    gtk_widget_show_all(window_login);
    gtk_main();

    return 0;
}


void initNetwork(int argc, char **argv) {
    int server_port = 0;
    char server_ip[16] = "";        // 16 = (max length of ipv4 string) + 1
    // Check arguments
    valid_arguments(argc, argv, server_ip, &server_port);

    char buff[BUFF_SIZE];
    struct sockaddr_in server_addr; /* server's address information */
    int msg_len, bytes_sent, bytes_received;

    client_sock_fd = socket(AF_INET, SOCK_STREAM, 0);

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);
    server_addr.sin_addr.s_addr = inet_addr(server_ip);

    if (connect(client_sock_fd, (struct sockaddr *) &server_addr, sizeof(struct sockaddr)) < 0) {
        notify("Error!Can not connect to sever! Client exit imediately!");
        return;
    }

    // Signal driven I/O mode and NONBlOCK mode so that recv will not block
    if (fcntl(client_sock_fd, F_SETFL, O_NONBLOCK | O_ASYNC))
        notify("Error in setting socket to async, nonblock mode");

    signal(SIGIO, signio_handler); // assign SIGIO to the handler

    //set this process to be the process owner for SIGIO signal
    if (fcntl(client_sock_fd, F_SETOWN, getpid()) < 0)
        notify("Error in setting own to socket");
}

void insert_message(char *time, char *sender, char *content) {
    GtkTextBuffer *buffer;
    GtkTextIter iter;
    char message[100];
    if (strcmp(sender, name) == 0)
        sprintf(message, "(%s)You :%s\n", time, content);
    else
        sprintf(message, "(%s)%s :%s\n", time, sender, content);
    buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(txt_chat_log));
    gtk_text_buffer_get_iter_at_offset(buffer, &iter, -1);
    gtk_text_buffer_insert(buffer, &iter, message, -1);
    gtk_text_view_set_buffer(GTK_TEXT_VIEW(txt_chat_log), buffer);
}

void clear_user_list() {
    GtkListStore *store;
    GtkTreeModel *model;
    GtkTreeIter iter;

    store = GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(list)));
    model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));

    if (gtk_tree_model_get_iter_first(model, &iter) == FALSE) {
        return;
    }

    gtk_list_store_clear(store);
}


void append_message(chat_history history) {
    for (int i = history.count - 1; i >= 0; i--) {
        insert_message(history.messages[i].sent_time,
                       history.messages[i].sender,
                       history.messages[i].content);
    }
}

void signio_handler(int signo) {
    char buff[BUFF_SIZE];
    char *rest;
    char code[RECV_LEN];
    char sender[30];
    char sent_time[30];
    char content[250];
    int i;

    int n = recv(client_sock_fd, buff, sizeof buff, 0);
    if (n > 0) // if SIGIO is generated by a data arrival
    {
        buff[n] = '\0';
        printf("Received from server: %s\n", buff);
        rest = buff;
        strcpy(code, strtok_r(rest, "|", &rest));
        if (!strcmp(code, HISTORY)) {
            strcpy(histories[chat_count].name, strtok_r(rest, "|", &rest));
            histories[chat_count].count = 0;
            while (strlen(rest) != 0) {
                i = histories[chat_count].count;
                strcpy(histories[chat_count].messages[i].sender, strtok_r(rest, "|", &rest));
                strcpy(histories[chat_count].messages[i].sent_time, strtok_r(rest, "|", &rest));
                strcpy(histories[chat_count].messages[i].content, strtok_r(rest, "|", &rest));
                histories[chat_count].count++;
            }
            show_history(histories[chat_count]);
            append_message(histories[chat_count]);
            chat_count++;
        }
        if (!strcmp(code, SENT_SUCCESS)) {
            printf("%s\n", success_sent(rest));
            strcpy(sender, strtok_r(rest, "|", &rest));
            strcpy(sent_time, strtok_r(rest, "|", &rest));
            strcpy(content, strtok_r(rest, "|", &rest));
            insert_message(sent_time, "You", content);
            gtk_entry_set_text(GTK_ENTRY(edt_message), "");
        }
        if (!strcmp(code, RECEIVE_MESSAGE)) {
            strcpy(sender, strtok_r(rest, "|", &rest));
            strcpy(sent_time, strtok_r(rest, "|", &rest));
            strcpy(content, strtok_r(rest, "|", &rest));
            printf("Got message: '%s' at %s from %s\n", content, sent_time, sender);
            if (strcmp(sender, current_chat_user) == 0) {
                insert_message(sent_time, sender, content);
                gtk_entry_set_text(GTK_ENTRY(edt_message), "");
            } else {
                update_mess_count(sender);
            }
        }
        if (!strcmp(code, LOGIN_SUCCESS)) {
            printf("LOGIN\n");
            if (strlen(name) <= 0) { //------> chua dang nhap
                strcpy(name, strtok_r(rest, "|", &rest));
                userArray = success_login(rest);
                printf("Logged in as %s\n", name);
                login_success();
                show_users(userArray);
                showUserList();
            } else { //----------> da dang nhap
                change_user_state(&userArray, already_login(rest), 0);
                show_users(userArray);
                showUserList();
            }
        }
        if (!strcmp(code, LOGIN_FAIL)) {
            printf("%s\n", fail_login(rest));
            notify(rest);
        }
        if (!strcmp(code, LOGIN_BEFORE)) {
            printf("%s\n", fail_login(rest));
            notify(rest);
        }
        if (!strcmp(code, SIGNUP_SUCCESS)) {
            if (strlen(name) <= 0) { //------> chua dang nhap
                strcpy(name, strtok_r(rest, "|", &rest));
                userArray = success_signin(rest);
                printf("Logged in as %s\n", name);
                login_success();
                show_users(userArray);
                showUserList();
            } else { //----------> da dang nhap
                add_user(&userArray, already_login(rest));
                show_users(userArray);
            }
        }
        if (!strcmp(code, SIGNUP_FAIL)) {
            printf("%s\n", fail_signin(rest));
            notify(rest);
        }
        if (!strcmp(code, EXIT)) {
            char *logout_user = user_exit(rest);
            if (strcmp(name, logout_user)) {
                change_user_state(&userArray, logout_user, 1);
                show_users(userArray);
                showUserList();
            } else {
                exit(0);
            }
        }
        if (!strcmp(code, NOT_FOUND)) {
            printf("%s\n", not_found(rest));
            notify(rest);
        }
    }
}

void update_mess_count(char *sender) {
    int i;
    for (i = 0; i < userArray.count; i++) {
        if (strcmp(userArray.users->name, sender) == 0) {
            userArray.users->mess_count++;
            break;
        }
    }
    showUserList();
}

void send_request(char *message) {
    gint bytes_sent, msg_len;
    msg_len = strlen(message) + 1;
    bytes_sent = send(client_sock_fd, message, msg_len, 0);
    if (bytes_sent <= 0) {
        printf("\nConnection closed!\n");
    }
}

void login_success() {
    gtk_widget_hide(window_login);
    gtk_widget_show_all(window_main);
    current_window = window_main;
    char title[40];
    sprintf(title, "Chat work - %s ", current_user);
    gtk_window_set_title(GTK_WINDOW(window_main), title);
}

void notify(gchar *message) {
    GtkWidget *dialog;
    dialog = gtk_message_dialog_new(GTK_WINDOW(current_window),
                                    GTK_DIALOG_DESTROY_WITH_PARENT,
                                    GTK_MESSAGE_INFO,
                                    GTK_BUTTONS_OK,
                                    message);
    gtk_window_set_title(GTK_WINDOW(dialog), "Information");
    gtk_dialog_run(GTK_DIALOG(dialog));
    gtk_widget_destroy(dialog);
}

void clear_chat_log() {
    GtkTextBuffer *buffer;
    buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(txt_chat_log));
    GtkTextIter start, end;
    gtk_text_buffer_get_start_iter(buffer, &start);
    gtk_text_buffer_get_end_iter(buffer, &end);
    gtk_text_buffer_delete(buffer, &start, &end);
}

void on_changed(GtkWidget *widget) {

    GtkListStore *store;
    GtkTreeModel *model;
    GtkTreeIter iter;
    char *value, history_req[20];

    store = GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(list)));
    model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));

    if (gtk_tree_model_get_iter_first(model, &iter) == FALSE) {
        return;
    }

    if (gtk_tree_selection_get_selected(GTK_TREE_SELECTION(selection),
                                        &model, &iter)) {
        gtk_tree_model_get(model, &iter, LIST_ITEM, &value, -1);
        char value_new[30];
        strcpy(value_new, value);
        set_current_user_label(get_user_name_and_state(value_new));
        receiver_name = get_user_name(value_new);
        sprintf(history_req, "REQU|%s|0", receiver_name);
        clear_chat_log();
        send_request(history_req);
        strcpy(current_chat_user, receiver_name);
    }
}


void showUserList() {
    clear_user_list();
    int i = 0;
    for (i = 0; i < userArray.count; i++) {
        if (strcmp(userArray.users[i].name, current_user) == 0)
            continue;
        appendUser(userArray.users[i].name, userArray.users[i].state, userArray.users[i].mess_count);
    }
    selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(list));
    g_signal_connect(selection, "changed", G_CALLBACK(on_changed), NULL);
}


void appendUser(gchar *name, gint state, gint mess_count) {
    GtkListStore *store;
    GtkTreeIter iter;

    gchar userStr[50], stateStr[20];
    strcpy(stateStr, (state == 1) ? "Online" : "Offline");

    sprintf(userStr, "%s (%s) (%d)", name, stateStr, mess_count);

    store = GTK_LIST_STORE(gtk_tree_view_get_model(GTK_TREE_VIEW(list)));

    gtk_list_store_append(store, &iter);
    gtk_list_store_set(store, &iter, LIST_ITEM, userStr, -1);

}

void init_list(GtkWidget *list) {

    GtkCellRenderer *renderer;
    GtkTreeViewColumn *column;
    GtkListStore *store;

    renderer = gtk_cell_renderer_text_new();
    column = gtk_tree_view_column_new_with_attributes("List Item",
                                                      renderer, "text", LIST_ITEM, NULL);
    gtk_tree_view_append_column(GTK_TREE_VIEW(list), column);

    store = gtk_list_store_new(N_COLUMNS, G_TYPE_STRING);

    gtk_tree_view_set_model(GTK_TREE_VIEW(list), GTK_TREE_MODEL(store));

    g_object_unref(store);

}

void set_current_user_label(char *user) {
    GtkTextBuffer *buffer;
    GtkTextIter start, end, iter;
    buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(txt_current_chat_user));
    gtk_text_buffer_get_start_iter(buffer, &start);
    gtk_text_buffer_get_end_iter(buffer, &end);
    gtk_text_buffer_delete(buffer, &start, &end);
    gtk_text_buffer_get_iter_at_offset(buffer, &iter, -1);
    gtk_text_buffer_insert(buffer, &start, user, strlen(user));
}


void initViews() {
    builder = gtk_builder_new();
    gtk_builder_add_from_file(GTK_BUILDER(builder), "windows.glade", NULL);
    window_login = GTK_WIDGET(gtk_builder_get_object(builder, "window_login"));
    gtk_window_set_title(GTK_WINDOW(window_login), "Login/Signup");
    gtk_window_set_position(GTK_WINDOW(window_login), GTK_WIN_POS_CENTER);
    gtk_window_set_default_size(GTK_WINDOW(window_login), 300, 300);
    current_window = window_login;

    window_main = GTK_WIDGET(gtk_builder_get_object(builder, "window_main"));
    gtk_window_set_title(GTK_WINDOW(window_main), "Chatwork");
    gtk_window_set_position(GTK_WINDOW(window_main), GTK_WIN_POS_CENTER);
    gtk_window_set_default_size(GTK_WINDOW(window_main), 600, 600);

    edt_message = GTK_WIDGET(gtk_builder_get_object(builder, "edt_message"));
    txt_chat_log = GTK_WIDGET(gtk_builder_get_object(builder, "txt_chat_log"));
    txt_current_chat_user = GTK_WIDGET(gtk_builder_get_object(builder, "txt_current_chat_user"));
    btn_login = GTK_WIDGET(gtk_builder_get_object(builder, "btn_signin"));
    btn_signup = GTK_WIDGET(gtk_builder_get_object(builder, "btn_signup"));
    btn_send_msg = GTK_WIDGET(gtk_builder_get_object(builder, "btn_send_msg"));
    lbl_notify = GTK_WIDGET(gtk_builder_get_object(builder, "lbl_notify"));
    edt_username = GTK_WIDGET(gtk_builder_get_object(builder, "edt_username"));
    edt_password = GTK_WIDGET(gtk_builder_get_object(builder, "edt_password"));
    vbox_user_list = GTK_WIDGET(gtk_builder_get_object(builder, "box_user_list"));

    set_current_user_label("Not currently chatting with any users");

    user_sw = gtk_scrolled_window_new(NULL, NULL);
    list = gtk_tree_view_new();
    gtk_container_add(GTK_CONTAINER(user_sw), list);
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(user_sw),
                                   GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(user_sw),
                                        GTK_SHADOW_ETCHED_IN);
    gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(list), FALSE);
    gtk_box_pack_start(GTK_BOX(vbox_user_list), user_sw, TRUE, TRUE, 5);
    init_list(list);
}

void initEvents() {
    g_signal_connect(G_OBJECT(window_login), "destroy", G_CALLBACK(gtk_main_quit), NULL);
    g_signal_connect(G_OBJECT(window_main), "destroy", G_CALLBACK(gtk_main_quit), NULL);
    g_signal_connect(G_OBJECT(btn_send_msg), "clicked", G_CALLBACK(btn_sendmsg_clicked_handler), NULL);
    g_signal_connect(G_OBJECT(btn_login), "clicked", G_CALLBACK(btn_signin_clicked_handler), NULL);
    g_signal_connect(G_OBJECT(btn_signup), "clicked", G_CALLBACK(btn_signup_clicked_handler), NULL);
    g_object_unref(builder);
}

char *get_time() {
    time_t rawtime;
    struct tm *timeinfo;
    char *output = malloc(30);
    time(&rawtime);
    timeinfo = localtime(&rawtime);

    sprintf(output, "%d/%d %d:%d", timeinfo->tm_mday, timeinfo->tm_mon + 1,
            timeinfo->tm_hour, timeinfo->tm_min);
    return output;
}

void btn_sendmsg_clicked_handler() {
    char request[200];
    sprintf(request, "SEND|%s|%s|%s", get_time(), receiver_name, gtk_entry_get_text(GTK_ENTRY(edt_message)));
    gtk_entry_set_text(GTK_ENTRY(edt_message), "");
    send_request(request);
}


void btn_signin_clicked_handler() {
    const gchar *username, *password;
    gint msg_len;
    msg_len = 101;
    username = gtk_entry_get_text(GTK_ENTRY(edt_username));
    password = gtk_entry_get_text(GTK_ENTRY(edt_password));
    char loginMessage[100];
    sprintf(loginMessage, "USER|%s|%s", username, password);
    send_request(loginMessage);
    strcpy(current_user, username);
}

void btn_signup_clicked_handler() {
    const gchar *username, *password;
    gint msg_len;
    msg_len = 101;
    username = gtk_entry_get_text(GTK_ENTRY(edt_username));
    password = gtk_entry_get_text(GTK_ENTRY(edt_password));
    char signupMessage[100];
    sprintf(signupMessage, "SIGN|%s|%s", username, password);
    send_request(signupMessage);
    strcpy(current_user, username);
}


void valid_arguments(int argc, char *argv[], char *serv_ip, int *serv_port) {
    if (argc > 2) {
        // Check valid ip address
        struct sockaddr_in tmp_addr;
        if (inet_pton(AF_INET, argv[1], &(tmp_addr.sin_addr)) == 0) {
            notify("IP Address is invalid!");
            exit(EXIT_FAILURE);
        } else {
            strcpy(serv_ip, argv[1]);
        }

        // Check valid port
        int i;
        char *port_str = argv[2];
        for (i = 0; port_str[i] != '\0'; i++) {
            if (!g_ascii_isdigit(port_str[i])) {
                notify("Port is invalid!");
                exit(EXIT_FAILURE);
            }
        }
        if (port_str[i] == '\0') *serv_port = atoi(port_str);
    } else {
        notify("(ERROR) To few arguments!");
        exit(EXIT_FAILURE);
    }
}

